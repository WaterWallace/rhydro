% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PhasedLoginterp.R
\name{PhasedLoginterp}
\alias{PhasedLoginterp}
\title{Calculate cross sectional area for a a range of periods}
\usage{
PhasedLoginterp(RatePer, offsets, points, stagedf)
}
\arguments{
\item{RatePer}{\emph{dataframe}, with columns \emph{PeriodStart}, \emph{End}, \emph{Phased}, \emph{TableNum}
\itemize{
\item{\emph{PeriodStart}}{ Posixct, start time of the rating period" }
\item{\emph{TableNum}}{ String, the section ID number to be applied for this time }
\item{\emph{Phased}}{ Boolean, TRUE of FALSE }
}}

\item{offsets}{dataframe, with columns "PeriodStart", "TableNum", "logOffset"
\itemize{
\item{\emph{TableNum}}{ String, the section ID of the cross section}
\item{\emph{logOffset}}{ Numeric, logOffset of this rating table, If zero, offset will be calculated }
}}

\item{points}{list, of dataframes, including \emph{from}, \emph{to}, \emph{ratingID}, \emph{QC}
\itemize{
\item{\emph{from}}{ Numeric, Reference value, i.e. height }
\item{\emph{to}}{ Numeric, Lookup value, i.e. discharge }
\item{\emph{ratingID}}{ String, ID of rating curve, i.e. "1", "Interim", "Debris1" }
\item{\emph{QC}}{ Integer, Quality code }
}}

\item{stagedf}{dataframe, with columns for a \emph{timestamp} and a \emph{height}
\itemize{
\item{\emph{timestamp}}{ posixct, Reference value, i.e. height }
\item{\emph{height}}{ Numeric, Lookup value, i.e. discharge }
}}
}
\value{
Vector of log interpolated data as read from the rating table,
same timestep as the input height.
}
\description{
Applies a rating table to height data for a time period
If the phased box is set to true, the result is based on a time factor between the
current rating table and the next rating table.
}
\details{
The input parameters \emph{RatePer}, \emph{offsets}, \emph{points}, are retrieved as a list
from an influx database retrieval script.
}
\examples{

#prepared exaple
data(tinana)
out <- PhasedLoginterp(rating$Periods, rating$Offsets, rating$XS, level)
plot(level$level.ts, out+0.001, log="y")

#Randomly generated example
library(dplyr)
set.seed(10)
#  random timeseries generator
maxht <- 5
ts <- ccInterp::StevesCoolRandomTS(maxht)
ts <- ts \%>\% dplyr::select(Time, Signal)

tmin <- ts$Time[1]
tmax <- ts$Time[nrow(ts)]

numperiods <- 6
periods <- data.frame(
  PeriodStart = seq(tmin, tmax, length=numperiods),
  TableNum = runif(numperiods, 1, 2*numperiods) \%>\% round \%>\% paste,
  Phased =  runif(numperiods, 0,1) \%>\% round \%>\% as.logical
)

plot(periods$PeriodStart, periods$TableNum, type = "s")

numTables <- unique(periods$TableNum) \%>\% length()
ratings <- list()
for(rating in 1:numTables)
{

  hts <- seq ( log(runif(1, 0.01, 0.1) ), log(max(ts$Signal)), length= 10 )
  hts <- exp(hts)

 ratingID <- unique(periods$TableNum)[rating]
 ratings[[ratingID]] <- data.frame(from = round(hts,3),
                                 to = round(hts^(runif(1, 2.5, 3.5)), 3),
                                 ratingID = ratingID,
                                 QC = 10 )
}

offsets <- data.frame(
TableNum = unique(periods$TableNum),
  logOffset = do.call(rbind,
  lapply(ratings,
  function(rating){
   rating <- rating[rating$to > 0,]
   min(rating$from) - 0.02
  })))

#calculate discharge with PhasedLoginterp()
ts$Discharge <- PhasedLoginterp(periods, offsets, ratings, ts)

par(mar = c(5, 4, 4, 4) + 0.3)  #'  Leave space for z axis
plot(Signal ~ Time, data = ts, type="l", col="darkgreen")
par(new = TRUE)
plot(ts$Time, ts$Discharge, type = "l", axes = FALSE, bty = "n", xlab = "", ylab = "", col="maroon")
axis(side=4, at = pretty(range(ts$Discharge)))
mtext("Discharge", side=4, line=3)

}
